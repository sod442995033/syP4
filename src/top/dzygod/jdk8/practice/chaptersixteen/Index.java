package top.dzygod.jdk8.practice.chaptersixteen;

import com.sun.istack.internal.NotNull;

import java.lang.annotation.Repeatable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * @Author: dingziyuan
 * @Date: 2018/10/7 17:19
 * @Description: 第十六章 结论以及java的未来
 * 本章内容
 *  Java 8的新特性以及其对编程风格颠覆性的影响
 *  由Java 8萌生的一些尚未成熟的编程思想
 *  Java 9以及Java 10可能发生的变化
 */
public class Index {

    private final int[] arr = {2, 2, 3};


    public static void main(String[] args) {
//        test1();

        /**
         * 回顾
         *      行为参数化（Lambda 以及方法引用）
         *           传递一个Lambda表达式，即一段精简的代码片段
         *           传递一个方法引用，该方法引用指向了一个现有的方法
         *      流
         *          java8使用Stream对集合进行增强,java8之前的集合多次操作需要多次遍历
         *          而java8使用Stream流延算法,通过单次流遍历,一次性完成所有的操作
         *      CompletableFuture
         *          Java从Java 5版本就提供了 Future 接口。 Future 对于充分利用多核处理能力是非常有益的，
         *          因为它允许一个任务在一个新的核上生成一个新的子线程，新生成的任务可以和原来的任务同时运行。
         *          原来的任务需要结果时，它可以通过 get 方法等待 Future 运行结束（生成其计算的结果值）。
         *
         *           通过 Stream 你可以对一系列的操作进行流水线，通过 map 、 filter 或者其他类似的方法
         *              提供行为参数化，它可有效避免使用迭代器时总是出现模板代码
         *           类似地， CompletableFuture 提供了像 thenCompose,thenCombine,allOf 这样的
         *              操作，对 Future 涉及的通用设计模式提供了函数式编程的细粒度控制，有助于避免使用
         *              命令式编程的模板代码。
         *      Optional 以函数式的结构串接计算
         *          如果在程序中始终如一地使用 Optional<T> ，
         *          你的应用应该永远不会发生 NullPointerException 异常
         *          由于库自身提供了缺失值的检测机制，不再需要用户代码的干预。
         *      默认方法
         *          对个体程序的行为带来影响
         *      Java 的未来
         *          类型系统的改进
         *              1. 声明位置变量(泛型通配符上下行改为一个)
         *              2. 更多的类型推断(编译器对省略的类型进行推断,以var作为类型声明)
         *          模式匹配
         *              函数式语言通常都会提供某种形式的模式匹配——作为switch 的一种改良形式
         *              通过这种模式匹配，你可以查询“这个值是某个类的实例吗”，
         *              或者你也可以选择递归地查询某个字段是否包含了某些值
         *          更加丰富的泛型形式(Java泛型的两个局限性)
         *              1. 具化泛型
         *                  java中垃圾回收器无法确定运行时泛型的类型
         *                  。实现具化泛型的主要难点在于，Java需要保持后向兼容性，
         *                  并且这种兼容需要同时覆盖JVM，以及使用了反射且希望进行泛型清除的遗留         *
         *              2.泛型中特别为函数类型增加的语法灵活性
         *              3. 原型特化和泛型
         *          对不变性的更深层支持
         *              Java 8只支持三种类型的值，分别为：
         *                   简单类型值
         *                   指向对象的引用
         *                   指向函数的引用
         *          值类型
         *              为什么编译器不能对 Integer 和 int 一视同仁
         *                  简单变量，特征比较采用的是逐位比较（bitwise comparison），
         *                  对象类型它采用的是引用比较（reference equality）
         *              值对象——无论简单类型还是对象类型都不能包打天下
         *                  Java中有两种类型的值：一类是对象类型，
         *                  它们包含着可变的字段（除非使用了 final 关键字进行修饰），
         *                  对这种类型值的特征，可以使用 == 进行比较；
         *                  还有一 类是值类型，这种类型的变量是不能改变的，
         *                  也不带任何的引用特征（reference identity），
         *                  简单类型就属于这种更宽泛意义上的值类型。
         *              装箱、泛型、值类型——互相交织的问题
         *                  我们希望能够在Java中引入值类型，因为函数式编程处理的不可变对象并不含有特征
         *
         *
         */

    }

    private static void test1() {
        /**
         * 催生java8的原因
         *  对多核处理器处理能力的需求日益增长，虽然硅开发技术也在不断进步，但依据摩尔定
         * 律每年新增的晶体管数量已经无法使独立CPU核的速度更快了。简单来说，要让你的代
         * 码运行得更快，需要你的代码具备并行运算的能力。
         *
         *  更简洁地调度以显示风格处理数据的数据集合，这一趋势不断增长。比如，创建一些数
         * 据源，抽象所有数据以符合给定的标准，给结果运用一些操作，而不是概括结果或者将
         * 结果组成集合以后再做进一步处理。这一风格与使用不变对象和集合相关，它们之后会
         * 进一步生成不变值。
         */}

}


